#include <stdio.h> 
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <string.h>
#include <sys/uio.h>
#include <malloc.h>

/*----------FUNCIONES EXTRA-----------*/

/*
* SEEK: Devuelve las posiciones en array y relativa.
*/
int seek_pos(int pos, struct iovec * array, int tam_array, int *pos_array, int *pos_rel){

	int count = 0, pos_array_loc = 0;

	if(pos < 0){
		printf("Error: Posición negativa.\n");
		return -1;
	}
	
	if(pos == 0){
		*pos_array = 0;
		*pos_rel = 0;
		return 0;
	}

	while(count < pos){
		
		//Comprobamos que la posición indicada esta dentro del array
		if (pos_array_loc > tam_array){ 
			printf("Error: La posición introducida es mayor al tamaño del string.\n");
			return -1;
		}
		count = count + array[pos_array_loc].iov_len;
		pos_array_loc++;
	}

	*pos_array = pos_array_loc - 1; //HAYA LA POSICION EN EL ARRAY DE ESTRUCTURAS
	*pos_rel = pos - (count - array[*pos_array].iov_len); //HAYA POSICION RELATIVA (Dentro del array)
	return 0;
}


/*----------FUNCIONES LIBRERIA---------*/

/*
* 1- PRINTF_V: Función que imprime una cadena "iov"
*/
void printf_v(struct iovec *iov, int tam_array){
	int i;
	for(i=0;i<tam_array;i++){
		write(STDOUT_FILENO,iov[i].iov_base,(iov[i].iov_len)*sizeof(char));
	}
}


/* 
* 2- INSERT_V: Inserta el string "a" en "b" en la posicion indicada SIN SOBREESCRIBIR
*	- Concatenar dos strings existentes.
*/
struct iovec * insert_v(struct iovec * a,int nodos_a, struct iovec * b, int nodos_b,int pos_in){

	int pos_nodo = 0,pos_rel = 0;
	struct iovec * new_node;

	//Busca y comprueba errores.
	if(seek_pos(pos_in,b,nodos_b,&pos_nodo,&pos_rel) == -1) 
		return;

	if (pos_rel == 0){ //PRINCIPIO DE NODO

 		new_node = (struct iovec *) malloc((nodos_b + nodos_a)*sizeof(struct iovec));

		//copiar estructuras anteriores
		memcpy(new_node,b,((pos_nodo)*sizeof(struct iovec)));	

		//copia "a"
		memcpy(new_node+pos_nodo,a,nodos_a*sizeof(struct iovec)); 

		//copiar estructuras posteriores
		memcpy(new_node+(pos_nodo+nodos_a),b+pos_nodo,(nodos_b-pos_nodo)*sizeof(struct iovec));

	}else{ //EN MEDIO DE NODO

		new_node = (struct iovec *) malloc((nodos_b + nodos_a + 1)*sizeof(struct iovec));

		//copiar estructuras anteriores
		memcpy(new_node,b,((pos_nodo)*sizeof(struct iovec)));

		//Copia estructura hasta "pos_rel"
		memcpy(new_node+pos_nodo,b+pos_nodo,sizeof(struct iovec));//copia nodo b
		new_node[pos_nodo].iov_len = pos_rel; //cambiamos el tamaño

 		//copia "a"
		memcpy(new_node+pos_nodo+1,a,nodos_a*sizeof(struct iovec));

		//Copia estructura desde "pos_rel"
		memcpy(new_node+(pos_nodo+1+nodos_a),b+pos_nodo,sizeof(struct iovec)); //copia nodo b
		new_node[pos_nodo+1+nodos_a].iov_base = new_node[pos_nodo+1+nodos_a].iov_base + pos_rel; //cambiamos el puntero
		new_node[pos_nodo+1+nodos_a].iov_len = new_node[pos_nodo+1+nodos_a].iov_len - pos_rel; //cambiamos el tamaño

		//copiar estructuras posteriores
		memcpy(new_node+(pos_nodo+nodos_a+2),b+pos_nodo+1,(nodos_b-pos_nodo+1)*sizeof(struct iovec));
	}
	return new_node;
}

/*
*	3- COPY_V: Realizar una copia de un string existente
*/
struct iovec * copy_v(struct iovec * a,int nodos_a, struct iovec * b, int nodos_b,int pos_in){
}

/*
*	4- DELETE_V: Borrar un rango de caracteres de un string
*/
struct iovec * delete_v(struct iovec * a,int nodos_a,int first, int last){
}

/*
*	5- COMPARE_V: Comparar dos strings existentes.
*/
int compare_v(struct iovec * a,int nodos_a, struct iovec * b, int nodos_b){
}

/*
* 5- INSERT_IN: Inserta el string "a" en "b" en la posicion indicada CON SOBREESCRITURA
*	- Insertar un nuevo substring en una posición dada para un string existente

void insert_in(struct iovec * a,struct iovec * b,int pos){

	if(pos < 0)
		printf("Error: Tamaño incorrecto.\n");

	int pos_array = 0, pos_rel = 0 count = 0; 

	while(count < pos){ //HAYA POSICION EN EL ARRAY
		count = count + b[pos_array].iov_len;
		pos_array++;
	}

	pos_array--;
	pos_rel = pos - (count - b[pos_array].iov_len);//HAYA POSICION RELATIVA (Dentro del array)

	if(b[pos_array].iov_len < pos_rel){ //CABE EN LA ESTRUCTURA VIEJA
		//sobrescribe desde pos_rel
		
	}else{
		if(!pos_rel) //NO CABE EN LA ESTRUCTURA VIEJA
			//Crear array ampliando nodo
			//copiar array cambiando nodo
		}else{
			//crear array con nodo extra
			//copiar array cambiando
			//reducir tamaño nodo anterior
	}



}

*/
int main(){

	char *str0 = "hello ";
	char *str1 = "world\n";
	char *str2 = "adios\n";

	struct iovec iov[2];
	struct iovec lec[1];
	struct iovec * salida;
	ssize_t nwritten,nread;
	int file;

	iov[0].iov_base = str0;
	iov[0].iov_len = strlen(str0);
	iov[1].iov_base = str1;
	iov[1].iov_len = strlen(str1);

	lec[0].iov_base = str2;
	lec[0].iov_len = strlen(str2);

	if((file = open ("file", O_WRONLY | O_CREAT | O_TRUNC, 0777)) == -1){ 
		perror("No se pudo abrir el fichero.\n"); 
		return;
	}

	nwritten = write_v(file, iov, 2);

	printf_v(iov,2);
	printf("-----\n");

	salida = insert_v(lec,1,iov,2,16);
	printf_v(salida,4);

	close(file);
}
































